# 메인 마크다운(README.md)
[▶ 메인 마크다운.md](README.md)

# *Ch03. Redis의 기본개념*
<details>
<summary>펼치기/접기</summary>

## 01. Redis 기본 설명(개념, 장점, 단점, 목적)

<details>
<summary>펼치기/접기</summary>

### Redis

`Re`mote `Di`*ctionary `S`torage  
Redis : memory 기반의 data 저장소 → 휘발성


- Disk가 아닌 Memory에 데이터를 저장
- Single Thread (CPU Thread 1개 사용)
- 초당 5만 ~ 25만 Request 실행가능  
key-value 형식으로 데이터 저장

### 장점 : Read/Write 속도

- Hardware 차이에서 오는 기본적인 performance gap
  HDD, SSD, RAM 등 여러 종류의 Hardware에 따라 속도가 확연히 차이난다.
- 다양한 type의 아키텍처를 지원한다. (Single, Master-Slave, Sentinel, Cluster)
  Sentinel: 마스터 슬레이브에서 발생될 수 있는 High Availability를 구현하기 위해 마스터의 이동이나 조정에 대한  
  역할을 수행하는 노드를 따로 두어 좀더 안정적인 레디스 운영을 가능하도록 만드는 구조
  Cluster : 복수개의 Master, 복수개의 Replica를 둬서 클러스터로 구성하여 재난이나 안전, 자체 하드웨어의 문제로 인해  
  Redis 서비스가 중단되지 않도록 하는 구조
- Partitioning
  데이터를 저장 할 경우 통으로 저장하는것이 아니라 여러 노드에 분산되서 데이터를 액세스하거나  
  그다음 데이터를 넣을 때도 파티셔닝 룰에 따라 분산되게 된다.
- Popular
  지원하는 라이브러리 같은 것들이 굉장히 다양(C#, Java, Python 등 그외 레어한 언어들에 대해서도)하며,  
  어떤 이유로 개발을 하다가 막히거나 에러를 발견 한 부분들에 대해서도 여러 조언이나 개선을 위한 방법들,  
  Recommendation 들을 비교적 편하게 찾아볼 수 있다.
- 
### 단점 : 휘발성

- `AOF, RDB Snapshot을 통해 Disk에 저장하여 휘발성 문제를 해소`  
  (램에 저장되어 있는 데이터들을 주기적으로 사용자가 선택한 룰에 따라 디스크에 저장하게 된다.)
- `Single Thread`  
  (데이터 정합성을 위함)
- `Memory Fragmentation`  
  Read/Write를 반복 하면서 메모리 자체에 완벽하게 들어가 있는 만큼만 사용되는게 아니다.    
  이미 데이터가 없는데도 사용하고 있다고 인식할 수 있다.  
  실제 가진 데이터보다 덜 이용하게 되거나 데이터가 있는데 없다고 인식되어 데이터가 저장되지 않는 등의 장애가 있음.
- `Big Size Data에 적합하지 않다`  
  휘발성이라는 문제를 해결하기 위해서 메모리로부터 데이터를 읽어들어 들이거나 변경된 부분에 대해 디스크에 Write하게 되는데  
  데이터가 너무 많이 들어가 있게 되면 디스크에 쓰는 시간이 굉장히 오래걸린다.  
  디스크 쓰는 시간이 너무 오래 걸리게 돼 버리면 리플리케이션과 싱크가 맞지 않는 경우가 생길 수 있고,  
  그 자체의 역할로 인해서 다른 요청들이 대기를 하고있는 상황이 있을 수 있다.  
  따라서 디스크 사용량을 줄이기 위해 다양한 옵션들을 설정하기도 한다.  
  램 용량을 많이 늘려 캐싱 용도가 아닌 데이터들도 저장해서 사용하면 안되냐 라고 할 수 있지만 너무 많은 데이터를 넣는 것은 적합하지 않다.

### 목적 : Caching

#### 캐싱이란?
자주 반복되는 자주 사용되고 빠르게 응답해야 되는 것들에 대한 준비를 미리 하는것.  
실제 원본에 가지 않아도 미리 임시적으로 갖고 있는 빠르고 효율성 높은 자원으로, 캐싱 구현시 사용자에게 좀 더  빠른 응답을 줄 수 있다.

- **클라이언트**    
  HTTP 캐시 헤더, 브라우저
- **DNS**  
  DNS 서버
- **웹**  
  HTTP 캐시 헤더, CDN, 역방향 프록시, 웹 액셀러레이터, 키-값 스토어
- **앱**  
  키-값 데이터 스토어, 로컬 캐시
- **데이터베이스**  
  데이터베이스 버퍼, 키-값 데이터 스토어

위와 같이 굉장히 다양한 계층에서 HTTP 캐시, DNS 서버, CDN, 로컬 캐시 등으로 사용될 수 있다.
캐시 계층을 따로 둬서 자체로 가지고 있는게 아니라 캐싱을 쓸 때는 Redis에 저장하도록 설정 해놓은 다음  
Redis에서 각 계층마다 필요한 데이터를 읽어가는 것이다.

### 일반적 사용 : Session Store, List Data Caching
(List 형태의 데이터가 응답이 굉장히 빠르다. - 일반 SQL RDB 서버보다 10배정도 이상의 성능을 낸다.)


</details>

## 02. 가격비교 Service에 사용될 Redis 구조 (Master-Replica, Sentinel, Cluster)
<details>
<summary>펼치기/접기</summary>

### Redis 구조

1. Stand Alone
   Redis 한대만으로 Master로 구성하여 사용  
 
2. Master-Replica
   Master인스턴스 Replica 혹은 Slave 인스턴스 두개의 인스턴스가 싱크를 맞추는 방식이다.  
   Replica가 Master로 싱크를 따라가는 구조이다.  
   보통 Replica는 Read만 가능하게 해놓는 경우가 많기 때문에 Master에서 데이터가 추가 혹은 삭제 등으로 변경이 되면
   Replica가 Master와의 차이점을 파악한 뒤 변경본에 대해서 실제 똑같이 복사하는 방식이다.  
   
3. Sentinel
   Master Replica 구조이면서 Master에 장애가 발생했을 때 일반적인 Master Replica 구조에서는 Master의 기동 유무만 파악하고
   아무런 동작을 하지 않고 끝나지만 실제로 Sentinel에서는 감시를 하다가 Master가 Down된것을 캐치하고 Replica를 Master로 전환한다.  
   Master 한대가 Down되더라도 Replica에서 다시 Master 역할을 하는 것으로 바뀐다.  
   Replica가 Master 역할을 하는 동안 원래 Master였던 1번 Redis를 복구한 뒤 Replica 역할로 붙힌다.
   이와 같이 두 Redis가 장애에 대해서 서로 상호 보완을 하게 된다.  
   Sentinel이라는 모니터링 툴 이라고 볼 수 있으며, 좀더 High Availity한 시스템을 구성할 수 있다.
4. Cluster  
   복수개의 Master - Replica 구조가 구성되어 있는 형태이다.  
   Master는 기본 3개로 구성되어 있어야 하고, 이에 Replica가 붙으며, 이때 붙는 Replica의 갯수는 상관이 없다.  
   클러스터를 구성할 경우 Sentinel이라는 것을 따로 띄우지 않아도 Master와 Replica간 서로 통신하면서 상황에 맞게 
   Master로 전환되는 등 서로 상호 보완하는 HA 구성이 되고, 데이터를 샤딩한다.

   샤딩이란 임의로 데이터셋을 나누는것을 말한다.  
   3건을 넣었다면 1곳에 들어갈 수 있지만 Hash Slot으로 분산하기 때문에 여러 군데 Master로 나뉘어서 들어가게 되고 
   실제 요청시 3개로 나뉘어서 응답을 받은 후 모아서 애플리케이션에 전달해 준다. 
   따라서 성능면으로도 좋다.
<br>
- **Availability** 가용성   
  Clsuter >= Sentinel(HA) > Master-Replica > SA
  Sentinel은 Cluster와 비슷하게 HA 구성을 하긴 하지만 두대가 동시에 내려가는 상황등은 보장할 수 없다.
  예를들어 Cluster 구조에서는 Replica 2대 혹은 Master 1대, Replica 1대가 내려가도 전혀 문제가 없다.  
  Master-Replica의 경우 Replca가 내려가는건 괜찮은 상황이다.
  Stand Alone의 경우 서비스가 아예 종료된다.

- **Performance** 성능  
  Cluster > Sentinel > Master-Replica > SA
  사실상 Sentinel과 Master-Replica는 거의 동등하다고 할 수 있지만 Sentinel은 Redis가 설치된 서버에 같이 설치하는 경우가  
  굉장히 많기 때문에 Sentinel이 Master-Replica 보다 오히려 안좋은 경우도 있다.
 
- **Efficiency** 효율성    
  SA > Master-Replica >= Sentinal > Clsuter
  Stand Alone은 온전히 혼자 사용하기 때문에 가장 적은 리소스로 어느 정도는 보장할 수 있다.  
  사실 MAster-Replica나 Sentinel은 비슷한 상황이지만, Cluster는 효율성이 떨어진다.  
  Master를 복수개로 구성함에 따라서 꽉 채워 사용한다기 보다는 여유있게 구성 해놓는 경우가 많기 때문.
  
3가지 성능적 측면에서 어떤 구조가 가장 좋은지를 고민해봤을때 기본적으로 Sentinel을 많이 선택한다.  
Master Replica를 서로 다른 존에 구성하고 만약 DR 상황(화재,정전)이 발생했을 떄 Master가 죽으면 Replica가 다른 존에 있기 때문에  
마스터의 역할을 할 수 있게 되기 때문에 이러한 구성을 많이 쓴다.  
만약 VM을 사용하는 구성일 경우 같은 VM도 마찬가지고 실제 물리 하드웨어도 마찬가지인데 같은 렉에 구성하지 않는 것이 바람직 하고  
같은 존에도 구성하지 않는 것이 좋다.  
만약 IDC가 두개면 두개의 IDC에 따라 다르게 혹은 IDC가 하나면 하나는 IDC 하나는 퍼블릭 클라우드 서비스와 같이 서로 분산해서 구성하는 것이 좋다.  
그렇기에 DR 상황에서도 장애를 최소화 할 수 있는 구성이 바로 Sentinel이다.  
Sentinel이 감시하면서 Replica를 Master로 돌려주기 때문에 좋다.
여러가지 후 조취를 한다면 Master-Replica도 Sentinel과 동일해 질 수 있다.  
앞부분에 밸런서가 있다고 가정할 경우 HeartBeat를 계속 감시 하다가 특정 인스턴스가 HeartBeat를 보내지 않을 경우 Script를 실행하게 해서
임의로 Replica를 Master로 돌리는 등의 작업을 할 수 있다.  
이러한 것들이 자동으로 구현된 것이 Sentinel이기 때문에 Sentinel이 효과와 안정성 면에서 조금 더 우위에 있다.  

사실 어떤 구조의 Redis를 선택하느냐는 사전에 정의한 품질 요건에 따라 달라진다.  
Availability를 99.95%로 설정했기에 4시간 안에 복구되어야 하는 상황이다.
과연 Master-Replica나 Stand Alone으로 구성할 경우 주말 혹은 휴가일 때 장애가 발생할 경우 대응 할 수 있을 것인가
혹은 항상 회사에 있는 상황이라고 할지라도 화재나 정전이 났을 때 렉 전체가 내려갔을 때 대응 할 수 있을 것인가 를 생각해보면  
불가능한 상황이 될 수 있다.  
부재중에는 4시간 안에 복구되기 굉장히 어려운 상황으로 누군가가 해줘야 하며 사람이 하게 만들것인가, 사람이 하더라도 장담 할 수 없기 때문에
시스템적인 장치를 통해 장애가 나더라도 Sentinel 프로세스가 모니터링 하다가 Master로 턴오버 시키는 작업을 하는것이 좋겠다 라고 판단 했기에
Sentinel 구성을 선택 한다.  
Performance는 현재 구조에서 확인할 수 없지만 Read가 300kb/s이기 땜누에 구성한 후에 실제 벤츠마크를 해본 후 얼만큼의 Read가 나올것인지 
또 어떤 데이터 타입을 Read하느냐에 따라 다르기 때문에 데이터 타입 까지 정한 다음 Redis 구성에 대한 퍼포먼스 검증도 해보는 것이 좋다.

 획득 가능한 자원이 VM 2대로 구성을 해야 할 경우 Cluster는 불가능하다.
물론 Port를 나눠 1개의 하드웨어, 1개의 VM을 2,3개의 인스턴스를 띄울 수 있으나 바람직 하지 않는 경우가 많다.
장애가 생겼을 때 해당 인스턴스에 같이 장애가 발생되는 것이기 때문에 서로 Effiency한 구조를 만들기 위해서는 작은 인스턴스라도 따로 띄우는 것이 좋고  
따로 띄웠을 때 서로 어떻게 리커버리 할 수 있는가를 고려하는 것이 좋다.  

Sentinel을 하게 되면 Redis를 2개 설치하고 1개를 받기로 했으니 앱 서버 1개에 Sentinel을 같이 설치한다.
각각의 서버에 Sentinel을 설치 하여 3개(?)의 Sentinel과 2개의 Redis를 설치할 수 있게 되어 비교적 HA한 구성을 만들 수 있게 된다.


</details>

## 03. Redis와 비슷한 다른 Solution - MemCached 
<details>
<summary>펼치기/접기</summary>

### Redis와 MemCached의 차이점

일반적으로 Redis는 MemCached의 기능의 대부분을 포함하고 있음.
Memcached도 AWS에서 프로덕트화되어 제공되고 있고, Redis도 마찬가지지만 Redis는 훨씬 더 많이 사용된다.  
그 이유는 처음에는 Memcached의 기능만으로 충분하다 생각하고 사용하던 서비스가 고도화되거나 확장되면서 점점 더 다양한 종류의 서비스를 추가해야 할 필요성이 생기기 때문이다.  
그럴 때 Memcached만으로는 부족한 경우가 발생할 수 있다.  
예를 들어, 처음에는 문자열 기준의 데이터만 다루다가 나중에는 다른 형태의 데이터를 저장하고 싶다는 요건이 생길 수 있다.  
물론 새로운 Redis를 추가하는 방법도 있지만, Memcached만 사용하기에는 한계가 있는 경우가 생긴다.  
또한 스케일링(Scaling) 문제도 비슷하다. 서비스가 커지면 더 많은 데이터를 처리하고, 더 많은 요청을 처리할 수 있어야 하기 때문에,  
Redis는 그만큼 더 유연하고 확장성이 뛰어나기 때문에 많이 사용된다.  
굳이 한쪽 캐시 솔루션을 사용할 거라면 레디스를 사용하는 것이 이점이 더 많을 것이라고 생각한다.  

**스케일링 이란?**
스케일링(Scaling)은 시스템의 성능을 더 많은 사용자가 접근하거나 더 많은 데이터를 처리할 수 있도록 확장하는 과정이다.  
스케일링은 수평적(서버를 늘리는 방식)과 수직적(서버 성능을 높이는 방식)으로 이루어질 수 있다.  
이 과정은 시스템이 커짐에 따라 점점 더 많은 부하를 처리할 수 있게 하며, 서비스의 안정성과 확장성을 높이는 데 중요한 역할을 한다.


1. #### DataType  
   - Redis : Hash, List, Set, Sorted Set, Geo, String
   - MemCached : String
   <details>
   <summary>개념 정리</summary>
   
   Memcached와 Redis는 캐싱 솔루션으로 많이 사용되지만, 그 사용성에서는 큰 차이가 있다.  
   Redis는 다양한 데이터 타입을 지원하며 유연한 데이터 처리가 가능하지만, Memcached는 단순한 캐싱 작업에 적합한 경량 솔루션이다.  
   Redis는 기본적으로 여러 데이터 타입을 제공하여 원하는 방식으로 데이터를 처리하거나 반환받을 수 있다.  
   예를 들어 Hash는 Key-Value 형태로 데이터를 저장하고 관리하기에 적합하고,  
   List는 순서를 유지하며 데이터를 저장하고 관리할 때 유용하며,  
   Set은 중복 없는 데이터 집합을 관리할 때 사용된다.  
   Sorted Set은 반환받은 데이터를 다시 정렬할 필요 없이 바로 사용할 수 있는 장점이 있다.
   Geospatial은 지리적 데이터를 처리할 수 있는 특수 데이터 타입으로 지도 기반 애플리케이션에서 활용된다.  
   이처럼 Redis는 다양한 데이터 타입을 제공하여 복잡한 데이터를 간단하고 효율적으로 처리할 수 있다.  
   예를 들어 Hash를 사용하면 Key:Value 형태로 데이터를 저장하거나 List와 Set을 이용해 원하는 구조의 결과를 쉽게 얻을 수 있다.  
   또한, Redis는 Sorted Set과 같은 타입을 통해 데이터를 정렬된 상태로 제공하므로 별도의 정렬 작업이 필요 없어 데이터 처리 과정에서 시간을 절약하고 성능을 높이는 데 큰 도움이 된다.  
   반면, Memcached는 기본적으로 문자열 데이터만 저장할 수 있다.  
   따라서 문자열 외의 데이터 타입을 저장하려면 JSON 형식으로 변환하거나 다른 방식을 사용해야 한다.  
   Memcached를 사용할 때 JSON 형식으로 데이터를 저장하면 반환받은 데이터를 다시 JSON으로 변환해야 하는 일이 자주 발생하며,  
   이 과정에서 문자열이 잘못 저장되거나 일부 데이터가 누락될 경우 문제가 생길 수 있다.  
   JSON 문자열로 복잡한 객체를 저장했을 때 데이터가 조금만 손상되어도 파싱 에러가 발생할 수 있다는 점에서 Memcached는 간단한 데이터 저장 용도에는 적합하지만 복잡한 데이터를 다루기에는 한계가 있다.  
   예를 들어, Memcached는 빠르게 만료되는 세션 데이터나 간단한 메시지를 캐시로 저장할 때에는 가볍고 적합하지만, 복잡한 데이터 구조를 다뤄야 하거나 다양한 데이터 타입을 활용해야 할 경우에는 Redis가 훨씬 더 적합하다.
   </details>

2. #### Thread
   - Redis : Single Thread
   - MemCached : Multi Threads
   <details>
   <summary>개념 정리</summary>
   
   Redis는 싱글스레드로 동작하며, Consistency(일관성)를 많이 보장하기 위해 이러한 구조를 가지고 있다.  
   싱글스레드 환경에서는 명령이 순차적으로 처리되기 때문에 데이터 충돌이나 경합 문제를 줄일 수 있는 장점이 있다.  
   반면에 Memcached는 멀티스레드로 동작한다. 멀티스레드 구조를 통해 여러 스레드가 동시에 요청을 처리할 수 있어 병렬 처리가 가능하다는 이점이 있다.  
   이러한 차이로 인해 Redis는 높은 일관성이 요구되는 작업에 적합하고, Memcached는 다수의 요청을 동시에 처리해야 하는 환경에서 유리하다.
   </details>

3. #### Scale
   - Redis : Scale Out
   - MemCached : Scale Up
   <details>
   <summary>개념 정리</summary>
   
   Redis의 Scale Out은 옆으로 계속 붙일 수 있는 구조를 가지고 있다.  
   특히 클러스터를 구성했을 때, 만약 Master 3대와 Replica 3대를 운영 중이라도 리소스가 부족하면 5대, 7대처럼 쉽게 늘릴 수 있다.  
   반면 Memcached의 Scale Up은 하드웨어(H/W) 스펙을 올리는 방식이다.  
   예를 들어 64GB를 사용하다가 더 많은 공간이 필요하면 128GB로 업그레이드하는 식으로 동작한다.  
   그러면 두 방식의 차이가 뭐냐, 스케일 업보다 스케일 아웃이 훨씬 쉽다는 점이다.  
   스케일 아웃은 실제로 운영 중에도 바로 확장할 수 있어 훨씬 편리하다.  
   하지만 스케일 업의 경우에는 분명히 다운 타임이 필요한 상황이 많다.  
   하드웨어를 업그레이드하는 동안에는 서비스가 중단될 가능성이 크고, 그 시간 동안 클라이언트는 서비스를 이용할 수 없게 된다.  
   이 차이를 이해하면 Redis와 Memcached의 확장 방식에서 어떤 선택을 해야 할지 더 명확해진다.  
   </details>

4. #### Memory Policy
   - Redis : no eviction, volatire-lru, volatile-ttl, allkey-random
   - MemCached : LRU
   <details>
   <summary>개념 정리</summary>

   Redis의 메모리 정책 중 no eviction은 데이터를 지우지 않는 정책이다.  
   이 정책을 사용할 경우 메모리가 가득 차면 더 이상 새로운 데이터를 저장할 수 없고, 기존 데이터를 지우지 않는다.  
   volatile-lru는 Least Recently Used(LRU) 알고리즘을 적용하는 정책으로, 메모리가 부족해지면 가장 오래전에 사용되지 않은 데이터부터 차례대로 삭제된다.  
   volatile-ttl은 Time-to-Live(TTL) 값을 기준으로, 해당 키가 설정된 만료 시간에 가까워지면 TTL이 짧은 키부터 삭제된다.  
   이 정책은 TTL이 설정된 키들만 대상으로 하며, TTL이 짧은 순으로 삭제된다.  
   allkeys-random은 모든 키들 중에서 랜덤으로 데이터를 삭제하는 방식이다.  
   이 정책은 메모리가 부족할 때 모든 키가 후보가 되어 무작위로 삭제된다.
   반면, Memcached는 기본적으로 LRU(Least Recently Used) 정책만을 사용하며, 이 경우 액세스가 적었던 데이터를 기준으로 오래된 데이터를 삭제한다.  
   Memcached는 다른 기준으로 데이터를 삭제할 수 없고, 오로지 LRU 방식에 의존하여 데이터를 관리한다.
   </details>

5. #### Persistence
   - Redis : AOF, RDB
   - MemCached : None
   <details>
   <summary>개념 정리</summary>

   Redis는 AOF 파일이나 RDB 파일을 디스크에 쓰기 하므로, 하드웨어가 내려가더라도 그 파일을 통해 데이터를 복구할 수 있다.  
   이러한 방식으로 Redis는 일정 기간마다 RDB를 디스크에 쓰기로 설정할 수 있으며, 이 쓰기 주기에 따라 RTO(Recovery Time Objective)를 결정할 수 있다.  
   예를 들어, 내가 1분에 한 번씩 데이터를 디스크에 쓴다고 설정하면, 하드웨어만 정상이라면 서비스가 다운되더라도 1분 전에 저장된 데이터를 복구할 수 있다.  
   만약 디스크가 손상되어 해당 RDB 파일이 없다면 데이터를 복구할 수 없지만, 서비스가 내려가는 상황은 자주 발생하지 않는다.  
   그렇기 때문에 Redis는 어느 정도 데이터를 보관할 수 있으며, 이는 캐시만을 처리하는 Memcached와는 다르게 데이터를 일정 기간 보존하는 스토리지 역할도 할 수 있다는 점에서 차이를 보인다.
   </details>

6. ETC
   - Redis : LUA Script
   <details>
   <summary>개념 정리</summary>

   Lua는 파이썬과 비슷한 언어로, 스크립트를 통해 데이터를 읽고 쓰는 데 사용된다.  
   주로 데이터를 삽입할 때 많이 활용되며, 복잡한 작업이나 긴 작업을 처리할 때 유용하게 사용된다.
   </details>

</details>
</details>