# 메인 마크다운(README.md)
[▶ 메인 마크다운.md](README.md)

# *Ch03. Redis의 기본개념*
<details>
<summary>펼치기/접기</summary>

## 01. Redis 기본 설명(개념, 장점, 단점, 목적)

<details>
<summary>펼치기/접기</summary>

### Redis

`Re`mote `Di`*ctionary `S`torage  
Redis : memory 기반의 data 저장소 → 휘발성


- Disk가 아닌 Memory에 데이터를 저장
- Single Thread (CPU Thread 1개 사용)
- 초당 5만 ~ 25만 Request 실행가능  
key-value 형식으로 데이터 저장

### 장점 : Read/Write 속도

- Hardware 차이에서 오는 기본적인 performance gap
  HDD, SSD, RAM 등 여러 종류의 Hardware에 따라 속도가 확연히 차이난다.
- 다양한 type의 아키텍처를 지원한다. (Single, Master-Slave, Sentinel, Cluster)
  Sentinel: 마스터 슬레이브에서 발생될 수 있는 High Availability를 구현하기 위해 마스터의 이동이나 조정에 대한  
  역할을 수행하는 노드를 따로 두어 좀더 안정적인 레디스 운영을 가능하도록 만드는 구조
  Cluster : 복수개의 Master, 복수개의 Replica를 둬서 클러스터로 구성하여 재난이나 안전, 자체 하드웨어의 문제로 인해  
  Redis 서비스가 중단되지 않도록 하는 구조
- Partitioning
  데이터를 저장 할 경우 통으로 저장하는것이 아니라 여러 노드에 분산되서 데이터를 액세스하거나  
  그다음 데이터를 넣을 때도 파티셔닝 룰에 따라 분산되게 된다.
- Popular
  지원하는 라이브러리 같은 것들이 굉장히 다양(C#, Java, Python 등 그외 레어한 언어들에 대해서도)하며,  
  어떤 이유로 개발을 하다가 막히거나 에러를 발견 한 부분들에 대해서도 여러 조언이나 개선을 위한 방법들,  
  Recommendation 들을 비교적 편하게 찾아볼 수 있다.
- 
### 단점 : 휘발성

- `AOF, RDB Snapshot을 통해 Disk에 저장하여 휘발성 문제를 해소`  
  (램에 저장되어 있는 데이터들을 주기적으로 사용자가 선택한 룰에 따라 디스크에 저장하게 된다.)
- `Single Thread`  
  (데이터 정합성을 위함)
- `Memory Fragmentation`  
  Read/Write를 반복 하면서 메모리 자체에 완벽하게 들어가 있는 만큼만 사용되는게 아니다.    
  이미 데이터가 없는데도 사용하고 있다고 인식할 수 있다.  
  실제 가진 데이터보다 덜 이용하게 되거나 데이터가 있는데 없다고 인식되어 데이터가 저장되지 않는 등의 장애가 있음.
- `Big Size Data에 적합하지 않다`  
  휘발성이라는 문제를 해결하기 위해서 메모리로부터 데이터를 읽어들어 들이거나 변경된 부분에 대해 디스크에 Write하게 되는데  
  데이터가 너무 많이 들어가 있게 되면 디스크에 쓰는 시간이 굉장히 오래걸린다.  
  디스크 쓰는 시간이 너무 오래 걸리게 돼 버리면 리플리케이션과 싱크가 맞지 않는 경우가 생길 수 있고,  
  그 자체의 역할로 인해서 다른 요청들이 대기를 하고있는 상황이 있을 수 있다.  
  따라서 디스크 사용량을 줄이기 위해 다양한 옵션들을 설정하기도 한다.  
  램 용량을 많이 늘려 캐싱 용도가 아닌 데이터들도 저장해서 사용하면 안되냐 라고 할 수 있지만 너무 많은 데이터를 넣는 것은 적합하지 않다.

### 목적 : Caching

#### 캐싱이란?
자주 반복되는 자주 사용되고 빠르게 응답해야 되는 것들에 대한 준비를 미리 하는것.  
실제 원본에 가지 않아도 미리 임시적으로 갖고 있는 빠르고 효율성 높은 자원으로, 캐싱 구현시 사용자에게 좀 더  빠른 응답을 줄 수 있다.

- **클라이언트**    
  HTTP 캐시 헤더, 브라우저
- **DNS**  
  DNS 서버
- **웹**  
  HTTP 캐시 헤더, CDN, 역방향 프록시, 웹 액셀러레이터, 키-값 스토어
- **앱**  
  키-값 데이터 스토어, 로컬 캐시
- **데이터베이스**  
  데이터베이스 버퍼, 키-값 데이터 스토어

위와 같이 굉장히 다양한 계층에서 HTTP 캐시, DNS 서버, CDN, 로컬 캐시 등으로 사용될 수 있다.
캐시 계층을 따로 둬서 자체로 가지고 있는게 아니라 캐싱을 쓸 때는 Redis에 저장하도록 설정 해놓은 다음  
Redis에서 각 계층마다 필요한 데이터를 읽어가는 것이다.

### 일반적 사용 : Session Store, List Data Caching
(List 형태의 데이터가 응답이 굉장히 빠르다. - 일반 SQL RDB 서버보다 10배정도 이상의 성능을 낸다.)


</details>

## 02. 가격비교 Service에 사용될 Redis 구조 (Master-Replica, Sentinel, Cluster)
<details>
<summary>펼치기/접기</summary>

### Redis 구조

1. Stand Alone
   Redis 한대만으로 Master로 구성하여 사용  
 
2. Master-Replica
   Master인스턴스 Replica 혹은 Slave 인스턴스 두개의 인스턴스가 싱크를 맞추는 방식이다.  
   Replica가 Master로 싱크를 따라가는 구조이다.  
   보통 Replica는 Read만 가능하게 해놓는 경우가 많기 때문에 Master에서 데이터가 추가 혹은 삭제 등으로 변경이 되면
   Replica가 Master와의 차이점을 파악한 뒤 변경본에 대해서 실제 똑같이 복사하는 방식이다.  
   
3. Sentinel
   Master Replica 구조이면서 Master에 장애가 발생했을 때 일반적인 Master Replica 구조에서는 Master의 기동 유무만 파악하고
   아무런 동작을 하지 않고 끝나지만 실제로 Sentinel에서는 감시를 하다가 Master가 Down된것을 캐치하고 Replica를 Master로 전환한다.  
   Master 한대가 Down되더라도 Replica에서 다시 Master 역할을 하는 것으로 바뀐다.  
   Replica가 Master 역할을 하는 동안 원래 Master였던 1번 Redis를 복구한 뒤 Replica 역할로 붙힌다.
   이와 같이 두 Redis가 장애에 대해서 서로 상호 보완을 하게 된다.  
   Sentinel이라는 모니터링 툴 이라고 볼 수 있으며, 좀더 High Availity한 시스템을 구성할 수 있다.
4. Cluster  
   복수개의 Master - Replica 구조가 구성되어 있는 형태이다.  
   Master는 기본 3개로 구성되어 있어야 하고, 이에 Replica가 붙으며, 이때 붙는 Replica의 갯수는 상관이 없다.  
   클러스터를 구성할 경우 Sentinel이라는 것을 따로 띄우지 않아도 Master와 Replica간 서로 통신하면서 상황에 맞게 
   Master로 전환되는 등 서로 상호 보완하는 HA 구성이 되고, 데이터를 샤딩한다.

   샤딩이란 임의로 데이터셋을 나누는것을 말한다.  
   3건을 넣었다면 1곳에 들어갈 수 있지만 Hash Slot으로 분산하기 때문에 여러 군데 Master로 나뉘어서 들어가게 되고 
   실제 요청시 3개로 나뉘어서 응답을 받은 후 모아서 애플리케이션에 전달해 준다. 
   따라서 성능면으로도 좋다.
<br>
- **Availability** 가용성   
  Clsuter >= Sentinel(HA) > Master-Replica > SA
  Sentinel은 Cluster와 비슷하게 HA 구성을 하긴 하지만 두대가 동시에 내려가는 상황등은 보장할 수 없다.
  예를들어 Cluster 구조에서는 Replica 2대 혹은 Master 1대, Replica 1대가 내려가도 전혀 문제가 없다.  
  Master-Replica의 경우 Replca가 내려가는건 괜찮은 상황이다.
  Stand Alone의 경우 서비스가 아예 종료된다.

- **Performance** 성능  
  Cluster > Sentinel > Master-Replica > SA
  사실상 Sentinel과 Master-Replica는 거의 동등하다고 할 수 있지만 Sentinel은 Redis가 설치된 서버에 같이 설치하는 경우가  
  굉장히 많기 때문에 Sentinel이 Master-Replica 보다 오히려 안좋은 경우도 있다.
 
- **Efficiency** 효율성    
  SA > Master-Replica >= Sentinal > Clsuter
  Stand Alone은 온전히 혼자 사용하기 때문에 가장 적은 리소스로 어느 정도는 보장할 수 있다.  
  사실 MAster-Replica나 Sentinel은 비슷한 상황이지만, Cluster는 효율성이 떨어진다.  
  Master를 복수개로 구성함에 따라서 꽉 채워 사용한다기 보다는 여유있게 구성 해놓는 경우가 많기 때문.
  
3가지 성능적 측면에서 어떤 구조가 가장 좋은지를 고민해봤을때 기본적으로 Sentinel을 많이 선택한다.  
Master Replica를 서로 다른 존에 구성하고 만약 DR 상황(화재,정전)이 발생했을 떄 Master가 죽으면 Replica가 다른 존에 있기 때문에  
마스터의 역할을 할 수 있게 되기 때문에 이러한 구성을 많이 쓴다.  
만약 VM을 사용하는 구성일 경우 같은 VM도 마찬가지고 실제 물리 하드웨어도 마찬가지인데 같은 렉에 구성하지 않는 것이 바람직 하고  
같은 존에도 구성하지 않는 것이 좋다.  
만약 IDC가 두개면 두개의 IDC에 따라 다르게 혹은 IDC가 하나면 하나는 IDC 하나는 퍼블릭 클라우드 서비스와 같이 서로 분산해서 구성하는 것이 좋다.  
그렇기에 DR 상황에서도 장애를 최소화 할 수 있는 구성이 바로 Sentinel이다.  
Sentinel이 감시하면서 Replica를 Master로 돌려주기 때문에 좋다.
여러가지 후 조취를 한다면 Master-Replica도 Sentinel과 동일해 질 수 있다.  
앞부분에 밸런서가 있다고 가정할 경우 HeartBeat를 계속 감시 하다가 특정 인스턴스가 HeartBeat를 보내지 않을 경우 Script를 실행하게 해서
임의로 Replica를 Master로 돌리는 등의 작업을 할 수 있다.  
이러한 것들이 자동으로 구현된 것이 Sentinel이기 때문에 Sentinel이 효과와 안정성 면에서 조금 더 우위에 있다.  

사실 어떤 구조의 Redis를 선택하느냐는 사전에 정의한 품질 요건에 따라 달라진다.  
Availability를 99.95%로 설정했기에 4시간 안에 복구되어야 하는 상황이다.
과연 Master-Replica나 Stand Alone으로 구성할 경우 주말 혹은 휴가일 때 장애가 발생할 경우 대응 할 수 있을 것인가
혹은 항상 회사에 있는 상황이라고 할지라도 화재나 정전이 났을 때 렉 전체가 내려갔을 때 대응 할 수 있을 것인가 를 생각해보면  
불가능한 상황이 될 수 있다.  
부재중에는 4시간 안에 복구되기 굉장히 어려운 상황으로 누군가가 해줘야 하며 사람이 하게 만들것인가, 사람이 하더라도 장담 할 수 없기 때문에
시스템적인 장치를 통해 장애가 나더라도 Sentinel 프로세스가 모니터링 하다가 Master로 턴오버 시키는 작업을 하는것이 좋겠다 라고 판단 했기에
Sentinel 구성을 선택 한다.  
Performance는 현재 구조에서 확인할 수 없지만 Read가 300kb/s이기 땜누에 구성한 후에 실제 벤츠마크를 해본 후 얼만큼의 Read가 나올것인지 
또 어떤 데이터 타입을 Read하느냐에 따라 다르기 때문에 데이터 타입 까지 정한 다음 Redis 구성에 대한 퍼포먼스 검증도 해보는 것이 좋다.

 획득 가능한 자원이 VM 2대로 구성을 해야 할 경우 Cluster는 불가능하다.
물론 Port를 나눠 1개의 하드웨어, 1개의 VM을 2,3개의 인스턴스를 띄울 수 있으나 바람직 하지 않는 경우가 많다.
장애가 생겼을 때 해당 인스턴스에 같이 장애가 발생되는 것이기 때문에 서로 Effiency한 구조를 만들기 위해서는 작은 인스턴스라도 따로 띄우는 것이 좋고  
따로 띄웠을 때 서로 어떻게 리커버리 할 수 있는가를 고려하는 것이 좋다.  

Sentinel을 하게 되면 Redis를 2개 설치하고 1개를 받기로 했으니 앱 서버 1개에 Sentinel을 같이 설치한다.
각각의 서버에 Sentinel을 설치 하여 3개(?)의 Sentinel과 2개의 Redis를 설치할 수 있게 되어 비교적 HA한 구성을 만들 수 있게 된다.


</details>

## 03. Redis와 비슷한 다른 Solution - MemCached 
<details>
<summary>펼치기/접기</summary>

### Redis와 MemCached의 차이점

일반적으로 Redis는 MemCached의 기능의 대부분을 포함하고 있음.

1. DataType
   - Redis : Hash, List, Set, Sorted Set, Geo, String
   - MemCached : String
2. Thread
   - Redis : Single Thread
   - MemCached : Multi Threads
3. Scale
   - Redis : Scale Out
   - MemCached : Scale Up
4. Memory Policy
   - Redis : no eviction, volatire-lru, volatile-ttl, allkey-random
   - MemCached : LRU
5. Persistence
   - Redis : AOF, RDB
   - MemCached : None
6. ETC
   - Redis : LUA Script
   - MemCached :

</details>
</details>