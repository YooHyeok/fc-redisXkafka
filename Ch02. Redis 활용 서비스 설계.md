# 메인 마크다운(README.md)
[▶ 메인 마크다운.md](README.md)

# *Ch02. Redis 활용 서비스 설계*
<details>
<summary>펼치기/접기</summary>

## 01. Use Case에 기반한 서비스 요구사항 정의 for Redis

<details>
<summary>펼치기/접기</summary>

### 요구사항 정의
요구사항이란?

간단하게 **클라이언트가 원하는것, 원하는 기능**을 말한다.  
이러한 요구사항을 정리하고 정의한다고 할때, 요구사항이 어떤 의미인지 명확하게 파악하고  
그것들에 대한 설명을 자세하게 적음으로써 서로가 이해하고 있는 말을 똑같이 맞추는것이다.

보통 클라이언트라고 하면 외부 고객이라고 생각할 수 있지만, **개발할 기능을 호출하는 서비스**  
예를들어 자사 서비스 내 타 부서에서 “우리 A라는 기능을 호출해야 하는데 너희가 만들어줘” 와 같은 상황에서도  
요청한 사람이 바로 클라이언트가 되는 것이고 그런 사람들과 보통 회의나 구두 전화통화 메신저 이메일 등을 통해  
이야가 히긴 하지만 이러한 것들을 잘 정리해 놓고 그 히스토리를 관리 해야 이 서비스가 어떤 의미에서 출발이 됐고  
그 서비스가 앞으로 어떤 방향을 가지고 발전이 될거다 라고 서로 기록하고 이해할 수 있다.

이러한 요구사항은 **단위 기능으로 뺄 수 있도록 정리**하는 것이 좋다.

차후에 이것들을 기능별로 정리를 해야하기 때문에 처음 받을 때 부터 단위 기능으로 정리할 수 있는건 빼 놓는것이 좋다.

**정리된 후에는 client와 의사소통을 통해 조정 및 확인**이 필요하다.

**자사 Project의 경우 이러한 합의나 요구사항이 회의내에서 논의되고 결정**된다.

합의나 요구사항이 회의 내에서 논의되고 결정이 끝나면 당시에는 서로 다 안다고 할 수 있는데 나중에 장애가 생긴다면 요구사항에 대해  
처음 정의했을 때와 말이 달라질 수 있기 때문에, **사전에 이것들을 명시화 하고 문서화 해서 상호 Confirm 하는 것이 매우 중요**하다. 

요청한 사람보다 서비스 제공자가 서비스 자체에 대한 내용을 더 잘 알고있는 경우가 훨씬 많기 때문에 **서비스 제공자가 확실하게   
짚고 넘어가지 않으면 고려하지 못하는 요구들이 너무 많다**.

(요구사항 정의서는 대게 외주 맡길때 많이 작성한다.)

예를들어 회원가입이라는 서비스에서 이메일 회원가입, SNS 회원가입 등의 기능이 필요하다고 가정해보자.
요구하는 사람은 SNS로 회원가입 했으면 좋겠어 라고만 이야기한다.
예를 들어 페이스북, 인스타그램, 카카오톡, 네이버 등 여러 SNS 중 어떤 매체를 통해 로그인이 필요한가 라고 물어볼 수 있지만, 이러한 사항들이 사전에 얘기되지 않고 그냥 SNS로 할거야 라고 말한다.
어떤 서비스에서 인증을 할 건지 서로 얘기를 미리 맞춰놓음으로써 추후에 우린 인스타그램으로 SNS 로그인 하려고 했는데 안되요? 라는 얘기가 나오지않도록 해야한다.


### 명확한 요구사항 파악을 위해 실무 중 확인해야 하는 정보

일 진행 순서 예시

`담당자` ─ 이메일, 전화 → `업무 회의` ─ 요구사항 → `개발담당자` ─ 반영→ `결과물`

어떤 담당자, 클라이언트가 이메일이나 전화나 메신저나 여러 수단을 통해서 문의를 해온다.
”우리 ~기능을 하고싶은데 너 해줄 수 있어?” 라고 연락이 오면 해당 부분에 대해 아주 간단한것 이라면 이미 있거나 바로 즉답을 할 수 있지만  
보통 업무 회의를 진행하여 서비스에 대해 파악을 한다.

- 이 서비스가 왜 개발되는 것인가?  
  : 메인 화면에서 상품 검색 시 가격별로 Sorting 하기 위해,  최저가 검색이라는 새로운 기능 런칭 시 핵심 기능  
  `영향 범위 파악, 확장성 고려`  
  예를들어 서비스가 죽으면 어떤 서비스에 영향이 가는것인지, 누구한테 연락을 해서 서비스가 죽었으니 어떠한 조치를 해라 라고 얘기를 할건지 확인을 해야한다.  
  또한 해당 서비스에서 파생되는 다른 서비는 없을지에 대한 고민이 필요하다. 확장성 있게 개발할 것인지, 아니면 단편적인 기능이라서 간단한 단위 기능 개발인지 생각을 해야한다.  
  (이러한 사항들에 따라 필요한 자원과 시간들이 많이 달리지기 때문)  

- 이 서비스의 런칭 시점이 어떻게 되는가?  
  : ASAP, 3개월 후 개발 런칭하여 Test, 검증 후 6개월 후 운영 적용    
  `개발 우선순위와 완성도에 영향`  
  예를들어 굉장히 급박할 경우 기능별로 순차적으로 오픈할 수 있는 개발 전략 등을 고려하기 위해 위와 같은 질문이 동반되어야 한다.  

- 이 서비스를 개발하기 위한 자원은 어떻게 확보되는가? (인적, 물적자원)  
  : 요청하는 부서에서 투자, 내년 예산 편입, 현재 유휴한 서버, 인력  
  `일을 하기 위해 필요한 도구가 준비되어 있지 않으면 영향을 줌`  
  충분히 확보되지 않는 상황이라면 질문을 꼭 해서 개발에 필요한 자원들을 확보 하여 주 목적인 서비스 런칭이 정상적인 기간에 런칭될 수 있도록 만드는 것이 중요하다.

- 이 서비스의 주요 Client가 어떻게 되는가?  
  `요구사항 합의, 개발 현황 공유, Client Test, 런칭 후 모니터링, 장애 공유`  
  처음 계획되지 않은 내용들, 개발하는 도중에 고려하지 못했던 부분들에 대해 누구랑 얘기해서 확인해야 하는가 등의 상황들이 생길 수 있다.  
  개발이 어느정도 진행되었다, 개발이 언제 완료 될것이다, 런칭이 언제 될것이다, 런칭 했다 라는 내용들을 어떻게 공유해야 하는가 등  

이러한  질문을 통해 여러 내용들을 파악한 뒤 요구사항으로 정리하고 개발 담당자가 개발 후 완성도 있는 결과물을 내놓게 된다.

### 간단한 요구사항 정의

서비스 명 : 특정 상품의 최저가 검색

서비스 요구사항 정의

1. 요구사항 명 : 최저가 반환
2. 요구사항 설명 : 상품명으로 상품을 검색하여 최저가를 Return
3. 중요도 : 상, 난이도 중

회의나 서신을 통해 요구사항이 정의되었고, 아주 간단한 서비스이기 때문에 위와같이 아주 간단하게 정의되었다고 가정했을 때   
우리는 위 요구사항을 보고 아래와 같이 굉장히 구체화 해 나갸아 한다.
<details>
<summary>구체화 예</summary>

- 상품명? 아라는 정의가 무엇인지?
- Char 라면 명확한 상품명 입력이 가능한건지?
- 상품의 ID를 준다는 의미인지?  
  (정확한 명칭? FullText? Code? 한글이름? 여러 의미의 대명사가 될 수 있음.)

- 한번에 하나씩 준다는 것인지? 묶음으로 준다는 것인지?  
  (10개를 한번에 주고 각각의 최저가를 뽑는것인지?)

- **상품의 Keyword를 준다는 것인지?**  
  현재 이 서비스에 상품 키워드를 주면 최저가로 리턴한다 라고 인식한다.  
  키워드 라는 것은 예를들어 골프공, 기저귀, 맥주 와 같이 키워드를 던지면 이와 관련된 상품들에 대해서 최저가를 준다라고 정의하고 서비스를 개발한다.

- 최저가? 라는 정의가 무엇인지?
- 가격의 단위는 원단위 까지 비교하는지?
- 묶음 수량의 경우 단위별 계산이 필요한지?
- 최저가 1개만 Return하면 되는건지?
- **최저가 묶음으로 전달한다면 몇 개를 전달하는 것인지?** (**10개**? 20개?)
- 단순히 가격만 전달하면 되는 것인지?
- Seller나 상품의 추가 정보는 기입하지 않아도 되는것인지?
- 최저가 묶음에 동일사업자의 동일상품이 있다면?
- 배송비를 포함하여 최저가를 검색해야 하는지? (무료배송 상품)


#### 도출
→ 키워드로 상품을 검색  
→ 중복없는 배송비 포함 최저가 10개를 전달
</details>

</details>

## 02. Use Case에 기반한 서비스 품질요건 정의 for Redis
<details>
<summary>펼치기/접기</summary>

### **품질 요건이란?**

해당 서비스가 갖춰야 하는 기능적 기술적 요건

기능적으로 어떻게 돌아가야 하고 기술적으로 어떻게 돌아가야 하는가?

1. `가용성`(Availability)  
   RTO, RPO, 장애, uptime / (uptime+downtime) * 100 → Five nine(99.95%)  
   서비스가 얼마나 가용 가능한가?  
   러닝이 얼마나 되는가?  
   결과적으로 서비스를 호출했을 때 응답받을 수 있는 시간(살아있는 시간)으로 1년 365일 중   
   365 * 24 인지 혹은 365 * 4~5 정도는 다운이 될 수 있는지.  
   Five Nine (99.95%): 약 4시간 정도 장애를 허용하며 그 외 시간은 항상 호출이 가능해야 한다.  
   RTO는 RecoveryTime, RPO는 RecoveryPoint로 장애가 났을 때 데이터가 복구할 수 있는 시점을 의미한다.
    - RTO: 장애가 발생한 후 얼마나 빠른 시간 내에 복구할 수 있는가
    - RPO: 장애 발생 시점부터 얼마 만큼의 데이터 복구가 가능한가    

   만약 Redis를 사용하고 Redis기동이 종료되었을 때 어느 시점까지 데이터를 확보할 수 있느냐 라고 정의 하는 것이며,  
   얼마만큼 빨리 장애에서 복구될 수 있는가에 대해 이야기 하는것인지를 정의 하는 것이다.  


2. `성능`  
   Ops/sec, TPS, Dataln/s, DataOut/s  
   Ops : 얼마만큼의 Operation이 초당 발생하는가? (허용가능여부)  
   TPS : 초당 데이터  
   DataIn/s : 초당 데이터는 얼마나 들어가도 되는가?  
   DataIn/s : 초당 데이터는 얼마나 나올 수 있는가?


3. `비용`
   얼마만큼의 자원을 사용하여 해당 기술을 구축할 것 인가?  
   즉, 서비스를 구축하고 운영하는 데 드는 비용을 의미한다.  
    해당 기술을 구축하기 위해 필요한 자원(서버, 네트워크, 인프라)의 사용량과 그에 따른 비용을 고려해야 한다.  


5. `보안`  
   정보의 탈취가능 여부, 노출 방지, 숨김, 다른 보안적 위협으로 부터 자유로운 지? 
   외부에 대한 침임, 노출, 해킹에 대한 위협에 있지 않은가에 대해 살펴보는 것.  
   즉, 서비스가 외부 공격이나 위협으로부터 얼마나 안전한지를 평가하는 항목이다.
5. `효율성`  
   해당 서비스를 사용, 유지/보수, 수정, 배포, 폐기, 복사 등의 작업을 하는데에 대한 업무 효율성  
   얼마나 소요되는가? 어떤 번거로움이 어떤 효율점이 있는지?  

외부 업체에서 정의 하고 있는 주요 항목들을 대입해 본 뒤 내 서비스가 해당 항목들에 대해 얼마 만큼이나 만족 시킬 수 있고, 그런 면에서 품질을 봤을 때 잘 만들어 졌는지 고민해서 만드는 것이 굉장히 중요하다.

### **가격비교 서비스의 품질요건**

1. 가용성(Availablitiy): 99.95% (연간 약 4.38시간의 다운타임 허용)  
   → Down이 발생되지 않게 하는 것도 중요하지만, Down 발생 시 정상화 방안과 그에 따른 목표 시간을 수립  
     - RTO(10분): 다운타임 발생 시, 최대 10분 이내에 시스템을 정상화 해야 한다는 목표
     - RPO(120초): 장애가 발생한 경우, 손실 가능한 데이터는 최대 2분 전 데이터로 제한한다는 목표  
   **이번 서비스는 99.95의 가용성을 가지는 서비스로 다운이 된다면 10분안에 복구가 되고, 2분 전 데이터 까지 복구  예정**


2. 성능, 용량:  
   → `200 Ops/sec, 200TPS`(Read 100, Write 100) 
     - 초당 200개의 작업 처리  

   → `Data-Out/s`: 한번 Return시 Out하는 Byte * ReadTPS = 300 Byte * 100 * 10 = 300Kb
     - 초당 출력되는 데이터를 300kb로 계산  
     - Redis의 데이터는 Key-Value 구조로 저장되며, 상품 그룹 ID를 Key로, 상품 ID와 가격 데이터를 Value로 사용한다.
       ```yaml
       Key: prodGrpId = "GP001001A"
       Value: [{ProdId:  Price}, {}, {}, {}, …] = [{P1A013BA: 1000000}, {P3B891BF}, {9800000}, {}, {}, …] * 10 
       Key: Value = "GP001001A": [{P1A013BA: 1000000}, {P3B891BF}, {9800000}, {}, {}, …] * 10
       ```
       상품 그룹 id 기준으로 상품 아이디와 가격에 대한 데이터를 10개씩 전달한다.  
   
   → `저장 용량`: 얼만큼의 데이터를 저장할 수 있는가? 예시 기준으로 2000만건 저장가능  


3. 비용: 얼마만큼의 자원을 사용하여 해당 기능을 구축할 것 인가?  
   → H/W  
     - Redis 서버: 8Core/32GB VM × 2대
     - 서비스 서버: 2Core/8GB VM × 1대
   → S/W: 오픈소스, 인력 : 자체개발 → 비용 절감


4. 보안: 내부망 안에서 사용되기에 외부 공격에 대한 보안 위협은 고려하지 않는다.


5. 효율성
   - API 설계: REST API 2.0 규격을 준수, Swagger 명세서 제공
   - 추후 계획: API Gateway 등록여부는 서비스 요구사항에 따라 결정

</details>

## 03. 서비스 논리 설계 for Redis
<details>
<summary>펼치기/접기</summary>

### **설계 요건과 자원**

- `API B/E Service` (2Core, 8Gb)
- `Redis Server` (8Core, 32Gb)

**데이터 구조**: Keyword > ProdGrpId > ProdId

- Keyword: 이어폰
    - ProdGrpId : 애플 에어팟 2
        - ProdId : 애플 공식 계정 에어팟 2
        - ProdId : 롯데배화점 에어팟 2
        - ProdId : 전자악세사리 전문업체  에어팟 2
    - ProdGrpId: 삼성 버즈 2
    - ProdGrpId: 이어킹 유선

#### 협의 완료 내용

- Keyword로 Input이 온다.
- ProdGrp별 ProdId와 Price를 반환한다.
- ProdGrp 10개 * prodGrp별 10개 {prodId: price}를 반환한다. (총 100개의 keyValue를 전달)

ex) 이어폰 keyword 검색시, 하기와 같이 반환
```yaml
[애플에어팟2: [[공식에어팟:249000, {롯데백…}], {삼성공식버즈:189000}, {전자랜드:178000}, {} …] …]
```

### 러프하게 그려보는 논리적 흐름
![KakaoTalk_20250101_223119044.png](img%2FKakaoTalk_20250101_223119044.png)
1. `API GET Request(keyword)` → `API B/E Service`  
2. `API B/E Service` **─키워드 조회 →** `Redis Server`  
3. 최초 Reids 조회  
   `API B/E Service` **← keyword:prodGrpId 조회 →** `Redis Server`  
   - Redis Server에 없다면 `Elastic Search` 조회  

    `API B/E Service` **← keyword:prodGrpId 조회 →** `Elastic Search`  
4. Elastic Search로 조회된 응답 데이터로 다시 Reids에서 조회  
   `API B/E Service` **← prodGrpId:{prodId, price}→** `Redis Server`  
    - Redis Server에 없다면 `Elastic Search` 조회
5. `API B/E Service` **← prodGrpId:{prodId, price} 조회─** `Elastic Search`  
6. `API GET Response` ← `API B/E Service`  

처음 특정 서비스에서 keyword를 API GET Request를 하게 되면 키워드별로 어떤 prodId가Redis에 저장되어있는지 혹은 캐싱되어 있는지 조회 한다.  
레디스는 주 기억장치 라기 보다 보조적이고 캐시 용도로 많이 쓰기 때문에 주로 사용되는 키워드라면 담겨 있겠지만, 그렇지 않다면 엘라스틱 서치에 해당 키워드에서 좋은 스코어를 갖는 도큐먼트 즉, 프로덕트 Id를 뽑아 API B/E service에 다시 전달한다.  
그럼 최근에 쓰였기 때문에, 키워드 별 프로덕트 id를 다시 레디스에 저장함으로 캐싱을 한다.  
그 다음 Elastic Serach를 통해 받아온 prodId를 받아 해당 id와 일치하는 {prodId, price} 리스트를 다시 받아온다.

1. 타 서비스에서 최저가 서비스 호출 (keyword)  
2. keyword: {prodGrpId,,, …}을 조회  
3. redis에 없다면 ElasticSearch에서 조회하여 prodGrpId 조회(상위 10건) 후 Redis 저장  
4. prodGrpId: [{prodId, price}, {}, …] 데이터 조회  
5. 없다면 ElasticSearch에서 ProdId 별 가격조회 후 반환  
6. 반환 후 Reids에 ProdId: Price 정보 저장

</details>
</details>