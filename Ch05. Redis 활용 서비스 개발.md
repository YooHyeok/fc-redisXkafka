# 메인 마크다운(README.md)
[▶ 메인 마크다운.md](README.md)

# Ch05. Redis 활용 서비스 개발
<details>
<summary>펼치기/접기</summary>

## REST API와 MVC 패턴 장/단점
<details>
<summary>펼치기/접기</summary>

### [MVC 패턴]  

                                          
사용자 → `**Browser**` → `**View**` → `**Controller**` → `**Model**`(Service, Repository)   
　　　　　　　　　　　　　　　　　　　　　　　　　　　　↓  
　　　　　　　　　　　　　　　　　　　　　　　　　　　`**Data**`  
　　　　　　　　　　　　　　　　　　　　　　　　  　　(SQL, NoSQL)


- **장점** : 분리, 확장 편의성  
  - `분리`: 각 역할을 명확히 분리함으로써, 사용자 인터페이스(View), 비즈니스 로직(Model), 요청 처리(Controller) 등을 독립적으로 개발하고 유지보수할 수 있다．
  - `확장성`: 각 컴포넌트를 독립적으로 수정하고 확장할 수 있어, 시스템을 쉽게 확장할 수 있다.  
             새로운 기능을 추가하거나 변경할 때 기존 구조에 미치는 영향을 최소화할 수 있다.
- **단점** : View ↔ Model간 의존성 발생, 시간 지날수록 복잡성 증가
  - `View ↔ Model 간 의존성 발생`: View가 Model의 데이터를 기반으로 동작하기 때문에 View와 Model 간의 간접적인 의존성이 생깁니다. 이로 인해 시스템이 커지면 의존 관계가 복잡해질 수 있다.
  - `시간이 지날수록 복잡성 증가`: 시스템 규모가 커지면 MVC 패턴을 유지하는 데 복잡도가 증가할 수 있다.  
       여러 Controller와 View가 얽히게 되면 관리가 어려워질 수 있다.
    - 특히, 대형 애플리케이션에서는 View와 Controller 간의 관계가 복잡해져서 코드가 비대해지고, 관리와 유지보수가 어려워질 수 있다.

</details>

## Redis Library 종류
<details>
<summary>펼치기/접기</summary>

### Lettuce vs Jedis

[비교 링크](https://redis.com/blog/jedis-vs-lettuce-an-exploration/)

- #### **Jedis** : 낮은 개발 복잡도.
  - 사용이 간단하며 낮은 개발 복잡도를 제공한다.
  - 동기 방식의 데이터 처리에 적합하며, 비교적 간단한 Redis 활용에 적합하다.
- #### **Lettuce** : 다양한 옵션 존재(advanced), Scaling, non-blocing reactive application에 유리
  - 다양한 옵션과 고급 기능(advanced)을 제공한다.
  - Scaling에 유리하다.
    - 여러 Redis 서버를 조합하여 데이터를 분산처리 하거나, Redis Cluster와 같은 환경에서 데이터 처리 성능을 확장하는 데 적합하다.
    - 대량의 데이터를 처리하거나 다중 사용자 요청을 처리할 때, 수평 확장을 통해 성능을 향상시킬 수 있다.
  - 비동기 반응형 애플리케이션 지원 (non-blocking reactive application)
    - 네트워크 요청이나 Redis 작업을 수행하는 동안 스레드가 대기하지 않고 다른 작업을 수행할 수 있도록 설계되어 있다.
    - WebFlux, Reactor, RxJava와 같은 반응형 프로그래밍 도구와 잘 연동된다.
    - 이를 통해 고성능 이벤트 기반 애플리케이션 개발이 가능하며, 대규모 트래픽 환경에서도 효율적으로 리소스를 활용할 수 있다.
</details>

## Redis Data Type
<details>
<summary>펼치기/접기</summary>

### 자료구조 종류
- #### **String**: 1:1관계
  - key-value 형태로 하나의 key에 하나의 value를 매핑한다.
  - 단순한 key-value 매핑 구조라서, Java의 Map과 유사하다.
- #### **List**: 순서존재, Queue와 Stack으로 사용
  - 순서가 있어서 데이터를 삽입한 순서대로 처리된다.
  - LPUSH, RPUSH 명령어를 통해 **Queue(FIFO)**와 Stack(LIFO) 구조로 사용 가능하다.
- #### **Sets**: 순서와 관계없이 저장, 중복 불가
  - 리스트처럼 여러 개의 값을 저장할 수 있지만, 순서는 중요하지 않다.
  - Set은 중복을 허용하지 않으며, 하나의 key에 여러 개의 Set 요소가 들어갈 수 있다.
- #### **`Sorted Sets`**: ZSET, Scode 개념 존재. Set과 같은데 정렬이 필요한 곳에 사용
  - Set과 비슷하지만, 각 요소에 Double 타입의 Score를 부여해서 정렬할 수 있다.
  - Score에 따라 자동으로 정렬되며, 순위 기반으로 데이터를 처리할 때 유용하다.
  - Double 타입(score)에 맞춰서 값의 크기에 따라 편리하게 조회할 수 있다.
    - 예를 들어, 가격이 100개가 있을 때, 가장 낮은 가격을 찾으려면 가장 작은 Score 값을 찾으면 된다.
    - RDB 환경에서 가격을 기준으로 ORDER BY를 사용하여 가장 저렴한 가격을 찾는 것과 유사하다.  
      그러나 Sorted Sets는 이미 정렬된 상태에서 값을 가져올 수 있어, 미리 정렬된 값을 빠르게 조회할 수 있는 장점이 있다.
- #### **Hashes**: Field:Value형태 여러 커플 존재. RDB의 TABLE 개념으로 많이 사용
  - 1:다 관계를 저장할 수 있다.
  - RDB의 테이블과 비슷한 구조로, 하나의 key에 여러 개의 field와 value를 매핑한다.
    - 예시: Key(테이블): A, Field(컬럼): 기억, Value: 1
  - RDB에 데이터를 저장하기 전 혹은 캐시 형태로 활용할 때 유용하다.

### Soroted Set(ZSET) 기본 명령어
- **ZADD**: 입력
  - 데이터를 추가한다.
- **ZCARD**: Count
  - 지정된 키에 몇개의 멤버가 들어있는지 카운팅한다.
- **ZRANGE**: 정렬순서로 조회
  - 예를들어 10개씩 조회한다면 1~10까지 조회하며, 인덱스는 0부터 시작한다. (0~9)
  - 만약 20개 항목이 필요하면 0~19까지 조회할 수 있다.
- **ZRANGEBYSCORE**: Score로 조회
  - 가격정보로 예를들면 1만원 ~ 2만원 사이 제품 중 가장 저렴한 것을 조회할 수 있다.
- **ZREM**: 삭제
  - 예를 들어, 더 이상 판매하지 않는 상품을 삭제할 때 사용한다.
- **ZSCORE**: 특정 멤버의 Scroe를 조회
  - 예를 들어, 제품의 가격을 조회할 때 사용된다.
- **ZRANK**: 특정 멤버의 Rank를 조회
  - 예를들어, 제품을 잘 구매한것인지 확인하고 싶은 유저가 있다면,  
    전체 상품 리스트에서 최저가 순으로 조회 해 봤을 때 몇 번째로 저렴한 제품을 구매했는지 확인할 수 있다.

</details>
</details>